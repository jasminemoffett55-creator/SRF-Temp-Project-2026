issue bc it is still returning days that dont exist. im not sure how to fix this

setwd("C:/Users/eliza.pease/Desktop/temp_data/data")

#install packages
install.packages(c("tidyverse", "lubridate", "janitor", "ggplot2", "zoo"))


#call in packages
library(tidyverse)
library(lubridate)
library(janitor)
library(ggplot2)
library(zoo)
library(tidyr)


#read in csv, clean names, and set datetime with only valid datetime 
WQ2014 <- read_csv("C:/Users/eliza.pease/Desktop/temp_data/data/WQ2014_clean_FINAL.csv") %>% #read in csv
  clean_names() %>% #clean/standardize col names
  mutate( 
    datetime = mdy_hms(timestamp), #make datetime object out of timestamp  
    location = str_trim(location), #get rid of spacing inconsistencies in location names
    date=as.Date(datetime, format = "%m/%d/%Y") # make date var which+ gets rid of time and only keeps date
    ) %>%
  filter(!is.na(datetime)) #only keep rows where datetime isnt missing


#only keep sites of interest 
sites_keep <- c("Big Creek", "Puma", "Upper Scott E-Fishing", "Weir", "Mill Creek")
WQ2014 <- WQ2014 %>%
  filter(location %in% sites_keep)

#calc daily mean temp 
daily_temp <- WQ2014 %>% #creates dataframe with mean temps 
  group_by(location, date) %>% #split data into groups based on unique combo of loc/date
  summarise(daily_mean_temp = mean(temperature_c, na.rm=TRUE), #take all temp readings for one day and ignore missing values within the day, compute avg and save it in new col 
            .groups = "drop")


# Create daily_temp_full by generating site-specific date ranges
daily_temp_full <- daily_temp %>%
  group_by(location) %>%
  # Create a sequence from the min to max date FOR EACH site
  reframe(
    date = seq(min(date), max(date), by = "day")
  ) %>%
  # Join the actual temp data back in
  left_join(daily_temp, by = c("location", "date")) %>%
  # Calculate rolling average within each site's specific range
  group_by(location) %>%
  arrange(date) %>%
  mutate(
    rolling_7d_mean = rollapply(
      daily_mean_temp,
      width = 7,
      FUN = function(x) if (all(!is.na(x))) mean(x) else NA,
      align = "right",
      fill = NA
    )
  ) %>%
  ungroup()



#create MWAT_by_site dataframe and calc MWAT per site 
MWAT_by_site <- daily_temp_full %>% #create MWAT_by_site from daily_temp_full 
  group_by(location) %>%
  summarise(
    MWAT_val = max(rolling_7d_mean, na.rm=TRUE), #find max of all valid rolling means 
    .groups= "drop"
  )


#add MWAT back for plotting 
daily_temp_full <- daily_temp_full %>%
  left_join(MWAT_by_site, by = "location") %>% #add MWAT_by_site to daily_temp_full
 mutate(
   facet_label = paste0(location, "\nMWAT = ", round(MWAT_val, 2),  " °C") #create new col called fact_label with site, location, line break
  )



date_check <- daily_temp_full %>%
  group_by(location) %>%
  summarise(
    first_real_temp = min(date[!is.na(daily_mean_temp)]),
    last_real_temp = max(date[!is.na(daily_mean_temp)]),
    last_valid_roll = max(date[!is.na(rolling_7d_mean)]), 
    .groups = "drop"
  )

print(date_check)



ggplot(daily_temp, aes(x= date)) + #sets up plot using dataframe daily_temp with horiz axis being date
  geom_line(aes(y= daily_mean_temp), color = "blue", alpha = 0.5) + #plot daily mean temp which shows mean of all temp readings for the day 
  geom_line(aes(y=rolling_7d_mean), color = "red", size = 1) +
  geom_hline(aes(yintercept = MWAT_val), color = "red", linetype= "dashed" ) +
  geom_text(
    data = MWAT_by_site, 
    aes(x =min(daily_temp$date), 
             y = MWAT_val, 
             label = paste0("MWAT = ", round(MWAT_val, 2), "°C " )),
        hjust =0, vjust= -0.5, 
        inherit.aes = FALSE
    )+ 
  facet_wrap(~location, scales = "free_x") + #plot 7day rolling avg, max value along red line = MWAT
  labs(
    title = "Daily Mean Temperature, 7 Day Rolling Mean, and MWAT",
    x = "Date", 
    y = "Temperature (°C)"
  ) + 
  theme_bw()

date_ranges <- daily_temp %>%
  group_by(location) %>%
  summarise(
    first_date = min(date, na.rm = TRUE),
    last_date = max(date, na.rm = TRUE),
    n_days = n(),  # how many days of data exist
    .groups = "drop"
  )

print(date_ranges)
